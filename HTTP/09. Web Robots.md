# 9장: 웹로봇

[학습 목표]

- 웹로봇에 대해 알아본다.
    - 스스로 움직이는 사용자 에이전트
    - 사람과의 상호작용 없이 연속된 웹 트랜잭션들을 자동으로 수행하는 소프트웨어 프로그램이다.
    - 방식에 따라 '크롤러', '스파이더', '웜', '봇' 등의 이름으로 불린다.

---

## 1) 크롤러와 크롤링

- 웹 크롤러란?
    - 먼저 웹 페이지를 하나 가져오고, 그 다음 페이지가 가리키는 모든 웹페이지를 가져오고, 다시 그 페이지들이 가리키는 모든 웹페이지를 가져오는 이러한 일을 재귀적으로 반복하는 방식으로 웹을 순회하는 로봇이다.
    - 웹링크를 재귀적으로 따라가는 로봇을 크롤러 혹은 스파이더라고 부른다.
    - 인터넷 검색엔진은 웹을 돌아다니며 만나는 모든 문서를 끌어오기 위해서 크롤러를 사용한다.

    ### ① 루트집합: 어디서 시작하는가?

    진짜 웹에서는 최종적으로 모든 문서로 이어지게 되는 하나의 문서란 없다.

    크롤러가 방문을 시작하는 URL들의 초기 집합은 루트집합(root set)이라고 불린다.

    일반적으로 좋은 루트 집합은 크고 인기 있는 웹사이트, 새로 생성된 페이지들의 목록, 자주 링크되지 않는 잘 알려지지 않은 페이지들의 목록으로 구성되어있다. 

    이 루트집합은 시간이 지남에 따라 성장하며 새로운 크롤링을 위한 시드 목록이 된다.

    ### ② 링크 추출과 상대 링크 정상화

    크롤러는 웹을 돌아다니면서 꾸준히 HTML 문서를 검색한다. 크롤러는 검색한 각 페이지 안에 있는 url 링크를 파싱해서 크롤링할 페이지 목록에 추가하고, 크롤링을 진행하면서 탐색할 새링크를 발견함에 따라 급속히 확장된다. 간단한 HTML 파싱으로 링크를 추출하고 상대링크를 절대링크로 변환할 필요가 있다.

    ### ③ 순환 피하기

    로봇들은 순환을 피하기 위해 반드시 어디를 방문했는지 알아야한다.

    순환은 로봇을 함정에 빠드려 멈추게 하거나 진행을 느려지게한다.

    ### ④ 루프와 중복

    순환은 최소 3가지 이유로 크롤러에 헤롭다.

    - 순환은 루프에 빠뜨려 꼼짝 못하게 만들 수 있다.
    - 크롤러가 같은페이지를 반복해서 가져오면 웹서버의 부담이 된다.
    - 쓸모없게 만드는 중복된 콘텐츠로 넘쳐날 수 있다.

    ### ⑤ 빵부스러기 흔적

    불행히도 방문한 곳을 지속해서 추적하는 것은 쉽지 않다. URL들은 굉장히 많기 때문에 어떤 URL 을 방문했는지 빠르게 판단하기 위해서는 복잡한 자료구조를 사용할 필요가 있다. (속도, 메모리 측면에서 효과적이어야한다.)

    - 방문한 곳을 관리하기 위한 유용한 기법
        - 트리와 해시테이블
        - 느슨한 존재 비트맵
        - 체크포인트: 급 중단된 경우, 방문 url 목록이 디스크에 저장되있는지 확인
        - 파티셔닝

    ### ⑥ 별칭(alias)와 로봇 순환

    올바른 자료구조를 갖추더라도 URL이 별칭을 가질수있는 이상 어떤 페이지를 이전에 방문했는지 말해주는게 쉽지 않을 수 있다. 한 URL이 또 다른 URL에 대한 별칭이라면 서로 달라보이더라도 사실은 같은 리소스를 가리키고 있다.

    ### ⑦ URL 정규화하기

    대부분의 웹 로봇은 URL들을 표준형식으로 '정규화'함으로써 다른 URL과 같은 리소스를 가리키고 있음이 확실한 것들을 미리 제거하려 시도한다.

    - 포트번호 명시 되어있지않다면 호스트명에 `:80` 을 추가한다.
    - 모든 `%xx` 로 이스케이핑된 문자들을 대응하는 문자로 변환한다.
    - `#태그` 들을 제거한다.

    위와 같은 방식만으로 웹서버에대한 지식없이 모든 중복을 피할수는 없다. 

    ### ⑧ 파일시스템 링크순환

    ### ⑨ 동적 가상 웹 공간

    악의적인 웹 마스터들이 죄없고 순진한 로봇들을 함정으로 빠뜨리기 위해 의도적으로 복잡한 크롤러 루프를 만드는 것은 있을 수 있는 일이다. 이보다 더 흔한 일은 웹 마스터가 나쁜의도는 없지만 자신도 모르게 심볼릭 링크, 동적콘텐츠를 통해 크롤러 함정을 만드는 일니다.

    ### ⑩ 루프와 중복 피하기

    모든 순환을 피하는 완벽한 방법은 없다. 일반적으로 자율적일수록 더 쉽게 곤란한 상황에 부딪힌다.

    웹에서 로봇이 더 올바르게 동작하기 위해 사용하는 기법들이 몇가지 있다.

    - URL 정규화: URL을 표준형태로 변환함으로써 같은 리소스를 가리키는 중복된 URL 발생을 일부 회피
    - 너비 우선 크롤링
    - 스로틀링: 웹사이트에서 일정시간 가져올 수 있는 페이지 숫자 제한. (접근횟수, 중복총횟수제한)
    - URL 크기 제한
    - URL/ 사이트 블랙리스트
    - 패턴발견
    - 콘텐츠 지문
    - 사람의 모니터링

## 2) 로봇의 HTTP

많은 로봇이 그들이 찾는 콘텐츠를 요청하기 위해 필요한 HTTP를 최소한으로만 구현하려한다.

### ① 요청헤더 식별하기

로봇들이 HTTP를 최소 한도로만 지원하려함에도 불구하고, 그들 대부분은 약간의 신원식별헤더( User Agent HTTP 헤더)를 구현하고 전송한다.

### ② 가상호스팅

로봇 구현자들은 Host 헤더를 지원할 필요가 있다. 그렇지 않으면 어떤 URL에 대해 잘못된 콘텐츠를 찾게 만든다.

### ③ 조건부 요청

로봇이 콘텐츠의 양을 최소화하는 것은 상당히 의미 있는 일이다. 오직 변경된 경우에만 콘텐츠를 가져오도록 한다. [캐시가 로컬 사본의 유효성을 검사하는 방식과 유사하다.]

### ④응답다루기

대다수 로봇은 주 관심사가 GET 메서드로 콘텐츠를 요청해서 가져오는것이기 때문에 응답 다루기라고 부를만한 일은 거의 하지 않는다. 단, HTTP의 특정 기능을 사용하는 로봇이나 웹 탐색이나 서버의 상호작용을 더 잘 해보려하는 로봇들은 여러 종류의 HTTP 응답을 다룰 필요가 있다.

- 상태코드: 로봇들은 최소 일반적인 상태코드, 예상할 수 있는 상태코드를 다룰수 있어야한다.
- 엔터티: meta-equiv태그와 같은 meta HTML 태그는 리소스에 대해 콘텐츠 저자가 포함시킨 정보다.

### ⑤ User-Agent Targeting

웹 관리자들은 많은 로봇이 그들의 사이트를 방문하게 될 것임을 명심하고, 그 로봇들로부터의 요청을 예상해야한다.

## 3) 부적절하게 동작하는 로봇들

제멋대로인 로봇들이 아수라장을 만들 여러 가능성이 있다. 로봇들이 저지르는 실수와 그로 인해 초래되는 결과를 몇가지 들어본다.

- 폭주하는 로봇: 로봇은 웹서핑을 하는 사람보다 HTTP 요청을 훨씬 빠르게 만들 수 있다.만약 로봇이 논리적인 에러를 갖고 있거나 순환에 빠지면 웹서버에 극심한 부하를 안길수 있고, 서버에 과부하를 유발해서 그 누구도 서비스를 사용하지 못하게 할수도 있다.
- 오래된 URL: 존재하지 않는 문서에 접근 요청으로 에러로그가 채워지거나, 에러페이지를 제공하는 부하로 인해 웹 서버의 요청에 대한 수용능력이 감소될 수 있다.
- 길고 잘못된 URL
- 호기심이 지나친 로봇
- 동적 게이트웨이 접근

## 4) 로봇 차단하기

로봇에 의한 웹사이트 접근이 유발할 수 있는 문제를 알고있고, 맞지 않는 장소에 들어오지 않도록 로봇의 동작을 제어할 수 있는 메커니즘을 제공하는 단순하고 자발적인 기법을 제안했다. 

표준은 'Robots Exclusion Standard' 이지만, 로봇의 접근을 제어하는 정보를 저장하는 파일이름을 따서 robots.txt라고 부르기도한다.

robots.txt 아이디어는 웹서버의 문서루트에 이 문서를 붙인 선택적인 파일을 제공하는 것이다. 이 파일로 서버의 어떤 부분에 접근 가능한지 정보가 담겨있다. 원하는 페이지를 요청하기 이전에 먼저 페이지를 가져올 수 있는 권한이 있는지 확인하기 위해 robots.txt 파일을 검사한다. 

서버가 `404 not found` 상태코드로 응답한 경우 로봇은 접근제한이 안된것으로 알고 어떤 파일이든 요청한다. 사이트관리자가 로봇접근을 추적가능하도록 `From`, `User-Agent` 에 신원정보를 넘긴다.

## 5) 로봇 에티켓

## 6) 검색엔진

웹 로봇을 가장 광범위하게 사용하는 것은 인터넷 검색엔진이다. 인터넷 검색엔진은 전세계의 어떤 주제에 대한문서라도 찾을 수 있게 해준다. 

오늘날 가장 유명한 웹사이트들의 상당수가 검색엔진이다.이들은 많은 웹사용자들의 시작점인 동시에 사용자들이 관심있는 정보를 찾을 수 있도록 도와주는 매우 유용한 서비스를 제공한다.

웹 크롤러들은 검색엔진에게 웹에 존재하는 문서들을 가져다주어서, 검색엔진이 어떤 문서에 어떤 단어들이 존재하는지에 대한 색인을 생성할 수 있게한다.

### ① 넓게생각하라

수백만명의 사용자들이 수십억개의 웹페이지에서 원하는 정보를 찾는 상황에서 수백만명의 사용자들이 생성하는 질의로 인한 부하를 다루기 위해 복잡한 질의 엔진이 필요한것 처럼, 검색엔진은 수십억개의 웹페이지들을 검색하기위해 복잡한 크롤러를 사용해야한다.따라서 작업을 완료하려면 많은 장비를 사용해서 요청을 병렬로 수행해야만 한다. 그러나 규모때문에 웹 전체를 크롤링하는 것은 여전히 쉽지 않은 도전이다.

### ② 현대적인 검색엔진의 아키텍처

오늘날 검색엔진들은 전세계의 웹페이지들에 대해 '풀텍스트 색인(full-text indexes)' 라고 하는 복잡한 로컬 데이터베이스를 생성한다. 

### ③ 풀텍스트 색인

풀텍스트 색인이란 단어하나를 입력받아 그 단어를 포함하고있는 문서를 즉각 알려줄 수 있는 데이터베이스다. 이 문서들은 색인이 생성된 후에는 검색할 필요가 없다.

### ④ 질의 보내기

HTML 폼을 사용자가 채워넣고, 브라우저가 GET 이나 POST요청을 이용해서 게이트웨이로 보내는 식. 질의를 받은 검색 게이트웨이 애플리케이션에 넘기면, 게이트웨이는 웹서버에게 결과를 돌려주고, 웹서버는 사용자를 위한 페이지로 변환한다.

### ⑤ 검색결과 정렬하고 보여주기

검색 결과에 순위를 매기고 똑똑한 알고리즘을 사용한다. 검색한 단어와 관련이 많은 순으로 결과 문서에 나타날 수 있도록 문서들 간의 순서를 알 필요가 있고 '관련도 랭킹(relevancy ranking)' 이라고 부른다. 검색 결과의 목록에 점수를 매기고 정렬하는 과정이다.

### ⑥ 스푸핑

웹 사이트를 찾을 때 검색 결과의 순서는 중요하다. 자신이 만든 사이트가 그 자신을 가장 잘 설명하는 단어로 검색 결과의 상단에 노출되도록 만들 동기가 충분하다. 검색 결과에서 더 높은 순위를 차지하고자하는 바람은 검색 시스템과 끝나지 않는 줄다리기를 한다. 따라서 많은 웹 마스터들이 수많은 키워드를 담은 가짜 웹 페이지를 만들거나, 검색엔진의 관련도 알고리즘을 속일 수 있는 특정 단어에 대한 가짜 페이지를 생성하는 게이트웨이 애플리케이션을 만들어 사용하기도 한다. 결국, 검색엔진및 로봇 구현자는 이런 속임수를 더 잘 잡아내기 위해 끊임없이 관련도 알고리즘을 수정해야만 한다.