# Design Patterns

### 개요

* 소프트웨어 엔지니어링에서 디자인 패턴이란, 
  소프트웨어 디자인에 일반적으로 발생하는 문제에 대한 
  일반적인 반복 가능한 솔루션.

* 디자인 패턴은 코드로 직접 변환할 수 있는 완성된 디자인은 아니다.
* 다양한 상황에서 사용할 수 있는 문제를 해결하는 방법에 대한 설명 또는 템플릿 이다.



#### Design Pattern의 사용

* 디자인 패턴은 테스트 되고 입증된 개발 패러다임을 제공하여 **개발 프로세스의 속도를 높힐** 수 있다.
* 효과적인 소프트웨어 설계에는 구현 후반까지 가시화 되지 않을 수 있는 문제까지 고려할 수 있어야한다.
* 디자인 패턴을 재사용하면 주요 문제를 일으킬 수 있는 미묘한 문제를 방지하고, 패턴에 익숙한 설계자(architects)와 coders에게 **가독성을 향상**시키는데 도움이 된다.

* 디자인 패턴은 일반적인 솔루션, 특정 문제와 관련 세부사항을 형식화한 문서를 제공한다.
* 추가적으로 패턴들은, 소프트웨어의 상호작용에 대해 잘 알려진 이름들을 사용함으로써 개발자들 사이의 **원활한 의사소통**을 가능하게 한다.
  (경제적임. 구현 방법을 일일이 설명하지 않고, 패턴 하나를 얘기함으로써 소통이 가능해지니까.) 





### 패턴의 분류(3가지)

#### Creational design patterns (생성 패턴)

* 요약
  * 클래스 인스턴스화에 관련된 패턴
    * 클래스 생성 패턴: 인스턴스화 프로세스에서 상속을 효과적으로 
    * 객체 생성 패턴 : 위임을 효과적으로 사용하여 작업 완료
  * 객체의 생성과 조합을 캡슐화하여 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성 제공.
* 종류
  * **Abstract Factory(추상 팩토리) ** 
    * 여러 유사한 클래스들에 대한 인스턴스 생성 
    * 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관/의존하는 객체들의 그룹으로 생성하여 추상적으로 표현
  * **Builder(빌더)**
    * 객체의 생성방법(object construction)과 표현 방법(representation) 을 분리
  * **Factory Method(팩토리 메서드)**
    * 여러 파생 클래스의 인스턴스를 만듬.**(공장)**
  * **Object Pool (객체 풀)**
    * 생성 가능한 인스턴스 갯수만큼 **메모리를 미리 할당해 풀**에 넣어두고, 필요할 때 꺼내쓰고, 사용이 끝나면 풀에 다시 반납해서 재사용 가능하게 함.
  * **Prototype(프로토타입)**
    * Original 객체(완전 초기화된 인스턴스)를 새로운 객체에 **복사**해서 필요에 따라 수정하는 매커니즘.
  * **Singleton(싱글톤)**
    * **단일 인스턴스**만 존재할 수 있는 클래스



#### Structural design patterns (구조 패턴)

* 요약
  * 클래스 및 객체 구성에 관한 것.
  * 클래스나 객체를 조합해 더 큰 구조(새로운 기능)를 만드는 패턴

* 종류
  * **Adapter**
    * 호환성 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환
  * **Bridge**
    * 구현부에서 추상층(인터페이스)을 분리해서 서로 독립적으로 확장할 수 있도록 구성
  * **Composite**
    * 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴
  * **Decorator**
    * 객체 간의 결합을 통해 능동적(동적)으로 기능을 확장(책임추가)할 수 있는 패턴
  * **Facade**
    * 전체 서브 시스템을 나타내는 단일 클래스
    * 복잡한 서브 클래스들을 피해서, 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
  * **Flyweight**
    * 인스턴스가 필요할때마다 매번 생성하는 것이 아니라, 가능한 공유해서 사용함으로써 메모리를 절약하는 패턴
  * **Private Class Data**
    * 돌연변이 접근 제한 (?, 전문을 봐야 알거같음;;)
  * **Proxy**
    * 접근이 어려운 객체와 접근하려는 객체 사이의 인터페이스 역할 



#### Behavioral design patterns (행동 패턴)

* 요약
  * 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴
  * 높은 응집도, 낮은 결합도
  * 객체간의 의사소통과 관련된 패턴
* 종류
  * **Chain of responsibility(책임 연쇄)**
    * 체인으로 연관된 객체간에 요청을 전달하는 방법 
      (객체 자신이 처리할 수 없는 경우, 다음 객체에게 문제를 넘겨 최종적으로 요청 처리 가능한 객체가 처리하도록 함.)
  * **Command(커맨드, 명령)**
    * 실행 될 기능을 캡슐화
  * **Interpreter(인터프리터, 언어 번역)**
    * 프로그램에 언어 요소를 포함 (SQL, 통신 프로토콜)
  * **Iterator(반복자, 같은 명령 반복)**
    * Collection 요소에 순차 접근
  * **Memento(메멘토)**
    * 개체의 내부 상태 복원 및 캡쳐
    * 객체를 특정 시점 상태로 돌릴 수 있는 기능 (Ctrl + Z와 같은 기능)
  * **Observer(옵저버, 변화를 지켜보고 알려줌)**
    * 한 객체의 상태 변화시, 상속되어 있는 다른 객체들에 알림. (시스템간 이벤트 생성 및 수신)
  * **State(상태)**
    * 상태의 변화에 따라, 객체의 동작을 다르게 처리해야할 때 사용.
  * **Strategy(전략)**
    * 동일한 계열의 알고리즘을 캡슐화 하여 상호 교환할 수 있게 정의
  * **Template method(템플릿 메소드)**
    * 상위 클래스에서 골격 정의, 하위 클래스에서 세부 처리를 구체화.
    * 유사한 서브 클래스의 공통 내용을 상위 클래스에서 정의
  * **Visitor(방문자)**
    * 클래스 변경없이 새 작업 정의







### 디자인패턴 비판

* 컴퓨터 과학 일부에 의해 비판
  * 잘못된 문제를 대상으로 함 
  * 공식적인 토대 부족
  * 비효율적인 솔루션으로 이어질 수 있음 (종종 불 필요한 코드 중복을 초래할 수 있음.)
  * 다른 추상화와 크게 다르지 않다.  
    (디자인 패턴이 다른 형태의 추상화와 크게 다르지 않고, 기존 현상을 설명하기 위해 새로운 용어를 사용할 필요는 없다고 평가 하기도 한다.)









---

