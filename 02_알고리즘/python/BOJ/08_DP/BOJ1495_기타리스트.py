# 메모리 초과 코드
N, S, M = map(int, input().split())
V = list(map(int, input().split()))

DP = [[] for _ in range(N+1)]
DP[0].append(S)

for i in range(1, N+1):
    for j in range(len(DP[i-1])):
        if DP[i-1][j] + V[i-1] <= M:
            DP[i].append(DP[i-1][j] + V[i-1])
        if DP[i-1][j] - V[i-1] >= 0:
            DP[i].append(DP[i-1][j] - V[i-1])
    if len(DP[i]) == 0:
        print(-1)
        break

if DP[N]:
    print(max(DP[N]))


'''
[문제 조건]
- 볼륨의 리스트 : V
- V[i]는 i번째 곡을 연주하기 전에 바꿀 수 있는 볼륨
- 항상 리스트에 적힌 차로만 볼륨 바꿀 수 있음 [예: 현볼륨 P, i번째곡 => P+V[i] or P-V[i]만 가능]
- 단, 0보다 작은값으로 볼륨 바꿀수 없음 + M보다 큰값으로 볼륨 바꿀 수 없음
- 곡의 개수 : N, 시작볼륨: S, 그리고 M이 주어졌을 때 마지막 곡으로 연주할 수 있는 최댓값 구하기

[입력 조건]
- 첫줄: N, S, M 
- 둘째줄: 각 곡이 시작전 줄수있는 볼륨차 [V1, V2, ... VN]
- 만약 마지막 곡 연주 할 수 없으면(중간에 볼륨 조절 안되면) -1 출력

[결과]
- 메모리초과
- 아무래도 배열의 크기를 지정해주지 않고, 그냥 list()로 할당하면서 메모리를 크게 잡은것 같다.
- for문의 스텝이 진행될 때마다 메모리에 재할당이 일어나면서 메모리 크게잡음(append 할때마다 메모리 재할당 받음 따라서, 크게 용량차지)
- 메모리를 덜 잡아먹기 위해서 일단 배열의 크기를 미리 지정해야 한다.
- 볼륨이 가능한 크기 즉, 0~M까지의 크기를 먼저 지정해서 문제를 풀어야 하는게 이 문제의 핵심이 아닐까?
- 따라서, [0,1,...,M] 까지의 크기의 배열을 N+1개 만들어 둔 다음에 N번째(마지막)에 해당 값이 true일 경우 그 index값이 볼륨의 값이 될것이다.
- 기타리스트_2.py에 적용해서 다시 풀어보기!
'''
