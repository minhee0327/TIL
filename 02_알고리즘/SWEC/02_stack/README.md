# Day2

-   ### 스택
    -   물건을 쌓아올리듯, 자료를 쌓아올린 형태 자료구조
    -   스택에 저장되는 자료는 선형구조를 가짐
        -   선형구조: 자료간의 관계가 1:1의 관계
        -   비선형구조: 자료간의 관계가 1:N의 관계(예: 트리)
    -   스택에 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있음
    -   마지막에 삽입한 자료를 가장 먼저 꺼냄
    -   후입선출(LIFO: Last in First Out)
    -   리스트를 사용하여 스택을 구현하는 경우
        -   장점: 구현 용이
        -   단점: 리스트 크기를 변경하는 작업은 내부적으로 overhead발생 작업으로 많은 시간소요됨
            -   대안
                -   리스트의 크기가 변동되지 않도록 배열처럼 크기를 미리 정해놓고 사용
                -   동적 연결리스트 이용하여 저장소를 동적으로 할당하여 스택 구현
-   ### 스택응용

    -   괄호검사 알고리즘 개요
        -   문자열에 있는 괄호를 차례대로 조사
            -   왼쪽 괄호 만나면 스택에 삽입
            -   오른쪽 괄호를 만나면 스택에서 top괄호를 삭제한후 오른쪽 괄호와 짝이 맞는지 확인
                -   스택이 비어있거나
                -   괄호의 짝이 안맞거나
                -   문자열 끝까지 조사한 후에도 스택에 괄호가 남아있으면
                -   괄호의 짝혹은 순서가 맞지 않다고 판별
    -   재귀호출
        -   자기 자신을 호출하여 순환 수행
        -   함수에서 실행해야 하는 자겅ㅂ 특성에 따라 일반 호출방식보다 재귀호출방식을 사용하여 프로그램 크기를 줄이고 간단히 작성할 수 있음.
        -   단, 디버깅이 어렵고(깊이가 깊어질수록..), 잘못 작성하게 되면 수행시간 많이 소요됨.

-   ### Memoization

    -   이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체 실행속도를 빠르게 하는 기술
    -   DP 의 핵심 개념
    -   글자그대로 메모리에 넣기라는 뜻
    -   Memorandum(라틴어), 기억되어야할것 이라는 뜻에서 파생

-   ### Dynamic Programming(DP, 동적 계획법)

    -   최적화 문제 해결알고리즘
    -   먼저 입력크기가 작은 부분 문제들을 모두 해결한 후, 그 해들을 이용해서 보다 큰 크기의 부분문제들을 해결
    -   최종적으로 원래 주어진 입력의 문제 해결
    -   구현방식
        -   함수 호출한 재귀적방법
            -   주의점: 내부 시스템 호출 스택을 사용하는 overhead발생가능
        -   반복문
            -   재귀적 구조보다는 성능면에서 효율적

-   ### DFS

    -   비선형구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요하다. (DFS, BFS)

        -   깊이우선탐색(DFS)

            -   stack 활용
            -   시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색
            -   더이상 갈 곳이 없게 되면 마지막 만난 갈림길 간선이 있는 정점으로 돌아옴
            -   다른 방향의 정점으로 탐색을 계속 반복해서 모든 정점을 반복순회
            -   가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선탐색을 반복해야하므로 후입선출구조 스택 사용
            -   알고리즘 개요

                -   시작정점(v)를 결정하고 방문
                    1. 정점 v에 인접한 정점중, 방문하지 않은 정점 w가 있으면
                        - 정점 v를 스택에 push하고 정점 w로 이동(방문)
                        - w를 다시 v로 하여 1. 반복
                    2. 방문하지 않은 정점이 없으면
                        - 탐색의 방향을 바꾸기 위해 스택을 pop해서 받은 가장 마지막 방문 정점을 v로 해서 다시 1.반복
                -   stack이 공백이 될때까지 반복한다.

                ```py
                def DFS(v):
                    visited = []
                    need_vistt = [] #stack

                    need_visit.append(v)
                    while need_visit:
                        node = need_visit.pop()
                        if node not in visited:
                            visited.append(node)
                            need_visit.extend(graph[node])
                    return visited
                ```
