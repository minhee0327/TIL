# 09. 프로세스간 커뮤니케이션\(IPC 기법\)

* 프로세스간 통신이 왜 필요할까?
  * 성능을 높이기 위해 여러 프로세스를 만들어 동시실행
  * 이 때 프로세스간 상태 확인 및 데이터 송수신 필요
* 프로세스간 통신 예제
  * fork\(\)시스템콜
    * fork\(\)함수로 프로세스 자신을 복제해서 새로운 프로세스로 만들 수 있음
      * 부모 프로세스, 자식 프로세스
    * 프로세스를 fork\)해서 여러 프로세스를 동시 실행 할 수 있음

      > 최근 CPU안에 코어가 8개 되는 경우도 많고  
      > 각 프로세스를 각 코어에서 동시실행 가능하기 때문\(병렬 처리 가능\)
  * 여러 프로세스 동시 실행하기 예
    * 1~10000까지 더하기
      * fork\(\)함수로 10개의 프로세스를 만들어서 1~1000,1001~2000,... 더하기  

        \(core가 10개 있다고 생각하면 병렬로 각 프로세스를 처리가능\)

      * 각각 더한 값을 모두 합하면 더 빠르게 동작가능
    * 단, 이 때 각 프로세스가 더한 값을 수집해야 하므로, 프로세스간 통신필요

      > CPU 병렬 처리 가능하면 빠른 대응 가능  
      > 각 프로세스 제어 및 상태 정보 교환을 위해 프로세스간 통신필요
* 프로세스간 공간은 완전히 분리되어있음
  * 하나의 프로세스는 총 4GB\(가상주소\)
    * 0~3GB: 사용자모드\(user mode\)
    * 3~4GB: 커널모드
  * 각 프로세스의 사용자 공간끼리는 서로 접근이 불가능하지만\(stack, heap, bss, data,code\)
  * 커널 공간은 실제 물리메모리에 동일한 공간을 공유할 수 있게끔 만들어져 있음.
  * 가상주소 != 물리주소
  * 더 깊은 내용은 가상메모리 참조
* **InterProcess Coummunication\(IPC\)기법**

  > 원칙적으로는 프로세스간 공간에 쉽게 접근 불가능  
  > 프로세스 데이터나 코드가 바뀌면 위험하니까~~!  
  > 따라서, 원칙상 프로세스는 다른 프로세스의 공간에 직접 접근 불가능!  
  > 프로세스간 어떻게 커뮤니케이션을 할 수 있을까?  
  > 프로세스간 통신방법을 제공! =&gt; IPC 기법
  >
  > * 한가지 방법: file 사용
  >   * 간단히 다른 프로세스에 전달할 내용을 file에 쓰고, 다른 프로세스가 해당 파일을 읽으면 됨
  >   * 다만, file을 사용하면 실시간으로 원하는 프로세스에 데이터 전달 어려움
  >     * 해당 프로세스가 파일을 읽어야하는데, 실시간으로 읽기 어려우니까.
  >     * 저장매체에 다녀와야하니까 오래걸림
  >   * \(커널 공간 사용하지 않음\)

  * 그래서 보다 다양한 IPC 기법이 있음
    * 핵심: 커널 공간을 사용하는 것\(물리메모리에 있음\)
    * file을 사용하는 것보다 빠른편
    * pipe
    * message queue
    * shared memory 
    * signal
    * semaphore
    * socket
    * ...

정리

* 여러 프로세스 동시 실행을 통한 성능개선, 복잡한 프로그램을 위해 프로세스간 통신 필요
* 프로세스간 공간이 완전 분리
* 프로세스간 통신을 위해 특별한 기법필요
  * IPC\(InterProcess Communicate\)
* 대부분의 IPC기법은 결국 커널 공간을 활용하는 것
  * 이유: 커널 공간은 공유하기 때문

참고\(시스템프로그래밍에서 실습함\)

* 각 IPC 기법 이해하기
  * pipe
    * 기본 파이프는 **단방향 통신\[부모\(write\) =&gt; 자식\(read\)\]**
    * fork\(\) 실행 다음 코드부터
      * 부모 프로세스
      * 자식 프로세스\(부모로 부터 복사한 프로세스\)
      * **ProcessID값이 다름\(부모: 실제 프로세스 ID, 자식: 0\)**
    * fork\(\)로 자식 프로세스 만들었을 때, **부모와 자식간의 통신**
    * 실제 데이터는 kernel 위치에 있음
  * message queue
    * 기본은 FIFO정책으로 데이터 전송
    * msgsnd\(\)로 메세지를 넣고
    * msgrcv\(\)로 해당 주소의 메세지를 읽어옴.
    * 동일한 key값을 통해서 각 프로세스를 데이터 송수신을 할 수 있다.
    * 먼저 넣은 데이터가 먼저 읽힌다.
    * **부모/자식 관계는 없음**
    * **양방향가능**
  * 공유메모리\(shared memory\)
    * 노골적으로 kernel space에 메모리 공간을 만들고 해당 공간을 변수처럼 쓰는 방식
    * 공유메모리 key를 가지고 여러 프로세스가 접근가능
      * shmget\(\)으로 공유 메모리 생성
      * shmat\(\)으로 공유메모리 주소 얻기
      * shmaddr\(\) 읽고, 쓰기 가능.
    * 커널공간에 아예 메모리 공간을 하나 파는 개념
  * signal\(가장 많이 사용됨!\)
    * 유닉스에서 30년 이상 사용된 전통적인 기법
    * 커널 또는 프로세스에서 다른 프로세스에 어떤 이벤트가 발생되었는지 알려주는 기법
      * \(커널 &lt;=&gt; 프로세스\)
      * \(프로세스 &lt;=&gt; 프로세스\)
    * 시그널은 미리 정의되어 있는 이벤트들  

      \(기본 OS \(Linux, Unix\) 에서 이미 정의되어 있음\)

      * SIGKILL
      * SIGALARM
      * SIGSTP 
      * ....
      * 특별한 동작을 정의할 수도 있다.

        > 터미널에 `kill -l` 입력하면 이미 정의된 시그널 종류를 볼 수 있음.

    * 프로세스 관련 코드에 관련 시그널 핸들러를 등록해서 해당 시그널 처리실행
    * PCB에서 해당 프로세스가 block또는 처리해야하는 시그널 관련 정보 관리
    * 커널모드에서 사용자모드로 전환시 시그널 사용.
  * socket\(가장 많이 사용됨!\)
    * 네트워크 통신을 위한기술
    * 기본적으로는 클라이언트와 서버 등 두개의 다른 컴퓨터 간에 네트워크 기반 통신을 위한 기술
    * 하나의 컴퓨터 안에서, 두개의 프로세스간에 통신기법으로도 사용가능

