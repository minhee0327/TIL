# 예외 및 에러처리

1. Error 객체 - ex1

   ```js
   const err = new Error("invalid error");
   ```

   - 위와 같이 인스턴스를 만드는 것만 가지고는 아무일도 일어나지 않음
   - 에러와 통신하는 수단임
   - instance of 연산자를 사용해서 Error 인스턴스가 반환되는지 확인
   - 에러메세지는 message프로퍼티에 있음!

2. try/catch 예외처리- ex2

   - 예상이 가능한 에러/ 예상치 못한 에러 모두 주의해야함
   - 예: email에 문자열이 아닌 숫자 null, 객체 등이 들어올때 프로그램은 앞뒤 설명없이 멈추게됨
   - 이를 catch하면, 프로그램이 멈추지 않고 에러를 기록한뒤 계속 진행을 시킬 수 있음.

3. 에러일으키기(throw)

   - 자바스크립트는 다른언어와 달리, 에러일으킬때 객체뿐만아니라 숫자, 문자열등 어떤값이든 catch절로 넘겨줄수있다.단, Error 인스턴스를 넘기는 것이 가장 편리.
   - throw를 호출하면 현재 함수는 즉시 실행을 멈추게 됨

   ```js
   function billPay(amount, payee, account) {
     //잔고가 인출하고자하는 값보다 작을때
     if (amount > account.balance) {
       //throw 호출하여 이 함수 즉시 멈춤. 잔고 빠져나가지 못함.
       throw new Error("insufficient funds");
     }
     account.transfer(payee, amount);
   }
   ```

4. 예외처리와 호출스택(call stack) - ex3

   - 호출스택 (call stack) : 완료되지 않은 함수가 쌓이는 것
   - 에러가 캐치 될때까지 호출 스택을 따라 올라감
   - 에러는 호출 스택 어디서든 캐치할 수 있고, 만약 에러를 어디에서든 캐치하지 않으면, 자바스크립트 인터프리터는 프로그램을 멈춰버림.
   - 이를 (unhandeled, uncaught)예외라고 부르고, 프로그램 충돌의 원인이 되기도 함
   - 에러 캐치는 호출스택 문제 해결에 유용한 정보를 얻을 수 있는데,
   - a함수가 b함수를 호출했고, b함수가 c함수를 호출한 상황에서 c에서 에러가 났을 경우, 호출 스택은 c에서 난 에러를 보고할 뿐만아니라, b가 c를 호출했고,a가 b를 호출한 것 까지 함께 알려줌. (디버깅에 효과적)
   - Error인스턴스에 스택을 문자열로 표현한 stack프로퍼티를 활용

5. try..catch..finally - ex4

   - try블록의 코드가 HTTP연결이나 파일과 같은 '자원'처리해야할 때
   - 프로그램쪽에서 계속 자원을 가지고있을 수 없음
   - 따라서, 언젠가는 이 자원을 해제해야함.
   - try블록에는 자원을 해제하는 것이 안전하지 않다.
   - 이럴때, finally블록이 필요!!(에러 유무와 관계없이 반드시 호출됨)

6. 정리
   - 예외를 캐치하지 못하면 프로그램이 정지할 수 있다.
   - 예외는 catch블록을 만날때까지 stack을 찾아 거슬러 올라가기때문에, 자바스크립트 인터프리터가 예외를 계속 추적해야한다.
   - 이런 예외상황은 비용을 발생시킬 수도 있고, 성능문제가 발생할 가능성이 있다.
   - 예외를 일으켰다면, 반드시 캐치해야한다. (예상할 수 없는 상황에서 마지노선으로 생각하고, 예상할 수 있는 에러는 조건문으로 처리하는 것이 최선!)
