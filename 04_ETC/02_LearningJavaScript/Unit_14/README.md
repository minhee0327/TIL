# 비동기적 프로그래밍
1. Intro 
    - JS App은 단일 스레드
    - (JS특성상) 부드럽게 동작하는 소프트웨어를 만들기 위해 사용자의 입력뿐만 아니라, 여러 문제를 비동기적관점에서 사고해야한다.
    - JS의 비동기적 프로그래밍에 뚜렷이 구분되는 3가지 패러다임
        - call back
        - Promise
        - 제너레이터
    - 사용자 입력외, 비동기적 테크닉을 사용해야하는 사례
        - Ajax로 호출을 비롯한 네트워크 요청
        - 파일을 읽고 쓰는 등의 파일 시스템 작업
        - 의도적으로 시간지연을 사용하는 기능

2. 콜백 (example01.js)
    - JS에서 가장 오래된 비동기적 매커니즘
    - 나중에 호출할 함수
    - 일반적으로, 다른 함수에 넘기거나, 객체의 프로퍼티로 사용하거나, 드물게 배열에 넣어서 사용
    - 보통 익명함수로 많이 사용.

3. 스코프와 비동기적 실행(example02.js)
    - 스코프와 클로저가 비동기적 실행에 영향을 미치는 부분이 혼란스럽고, 에러가 자주 일어나는 부분!!!
    - 함수를 호출하면 항상 클로저가 만들어진다.

4. 오류우선 콜백(example03.js)
    - 콜백과 관련된 에러를 처리할 방법의 표준이 필요
    - 콜백의 첫번째 매개변수에 에러 객체를 써자. (에러가 null이나 undefied면 에러가 없는 것)
    - Promise를 사용하지 않으면, 오류 우선 콜백은 노드 개발의 표준이나 다름 없음.
    - 콜백 사용 인터페이스를 만들 때는 오류 우선 콜백을 사용하자.

5. 콜백 헬

6. Promise (example04.js)
    - 콜백헬 개선 시도하면서 만들어짐
    - 안전하고, 관리하기 쉬운 코드를 만들 수 있음
    - 프로미스가 콜백을 완전히 대체하는 것은 아님. 
    - 콜백을 예층 가능한 패턴으로 사용할 수 있게 하고, 프로미스 없이 콜백만 사용했을 때 나타날 수 있는 엉뚱한 현상이나 버그를 상당수 해결
    - 기본개념
        - 프로미스기반 비동기적 함수를 호출하면, 그 함수는 Promise 인스턴스 반환
        - 성공(fullfilled)/ 실패(rejected) 둘 중 하나만, 단 한번만 일어남
        - 프로미스가 성공 혹은 실패하면, 그 프로미스를 결정됬다(settled)고 한다.
        - 객체이기 때문에 어디든 전달할 수 있다.
    - 프로미스 만들기
        - resolve(성공), reject(실패) 콜백이 있는 함수로 Pomise 인스턴스를 만들기만 하면된다.
    - 이벤트 (example05.js)
        - 이벤트 발생시,이벤트 발생을 담당하는 개체(emitter) 에서 이벤트가 일어났음을 알립니다.
        - Node에는 이미 이벤트를 지원하는 모듈 EventEmitter가 내장되어 있다. 
            - 함수와 함께 사용해도 되지만, 클래스와 함께 사용하도록 설계되어있다.
    - 프로미스체인
        - 프로미스는 체인으로 연결 가능
        - 프로미스가 완료되면, 다른 프로미스를 반환하는 함수를 즉시 호출할 수 있음.
        - 프로미스 체인을 사용하면 모든 단계에서 에러를 캐치할 필요 없이, 어디서든 에러가 생기면 체인 전체가 멈추고,  
        catch 핸들러가 동작한다.
    - 결정되지 않은 프로미스 방지하기
        - resolve나 reject를 호출하는 걸 잊어서 프로미스가 결정되지 않는 문제까지 자동으로 해결하지는 않는다.
        - error도 일어나지 않기 때문에 문제를 찾기 어려울 수 있다.
        - 따라서, 결정되지 않은 프로미스를 방지하는 한가지 방법은 프로미스에 타임아웃을 거는 것.
        - 충분한 시간이 지났는데도, 프로미스가 결정되지 않으면 자동으로 실패할 수 있게 만들 수 있다.
    -