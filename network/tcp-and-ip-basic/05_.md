# 05 트렌스포트 계층

* intro
  * 통신을 실현하는것
  * 트렌스포트: 수송하다, 운반하다
  * 데이터를 상대에게 전달하는 것
  * 상대 어플리케이션 계층에 있는 어떤 프로토콜에 전달할지 책임
  * 포트:
    * 어플리케이션 계층의 서비스 수만큼 존재하는 프로토콜중, 목적 프로토콜을 지정하기위한 장치
    * 어플리케이션 계층에 설치된 출입구. 각각을 개별 프로토콜로 가는 현관문이라고 생각하면 좋음.
    * 각 포트에는 포트번호라는 고유 숫자가 할당되어있음.
    * 프로토콜을 식별
    * 다른 통신 서비스를 동시에 사용할수있다.
* 트렌스포트 계층의 역할
  * 트렌스포트 계층은 에플리케이션계층과 네트워크 계층의 중개역할
  * 데이터를 전달하면서 문제가 발생한 경우 대처방안이 필요한데, 이 때 통신 서비스에 맞는 방법으로 처리하는 역할을 맡는다.
  * 신뢰성이냐, 속도냐에 따라 TCP/UDP라는 두개의 프로토콜로 나뉨.
    * TCP: 신용 우선. \(송신 데이터를 확실히 상대에게 전달하고 싶을때. WWW, 전자메일\)
    * UDP: 속도 우선. \(송신하는 패킷이 작거나, 데이터 재전송 필요 없을때. 스트리밍, IP전화\)
* 애플리케이션의 현관
  * application protocol마다 데이터의 출입구가 있고, 이 출입구를 '포트\(port\)'라고함
  * 각 포트마다 '포트번호'가 있음.
  * 통신을 수행할 때, 포트 번호를 사용해 보낼 곳 지정.
  * 포트 번호는 0~65535번까지 있고, 0~1023번까지 미리 예약된\(웰노운\)번호라고함
    * WWW서비스를 하는 application protocol은 HTTP, 포트번호는 80, 트렌스 포트 계층 프로토콜은 TCP/IP 이런식으로 예약되어있음.
  * 그 외의 포트 번호는 사용자가 임의로 설정 가능 \(단, 어떤 포트번호 사용할지는 인식 통일\)
* TCP프로토콜
  * 데이터 전달의 신뢰성을 중시한 프로토콜
  * 데이터를 확실히 전달하기 위해 수신측과 1:1 통신 \(커넥션형 통신\)
    1. 통신연결: 수신측이 데이터 받을 수 있는지 상태 확인후 통신 개시.
    2. 데이터를 정해진 크기로 분할하여, TCP헤더를 붙여 순서대로 송신.  

       여기서 취급하는 데이터 단위를 _**세그먼트**_라고함

    3. 데이터 다 보내면 통신 종료
  * 수신측과 연락을 긴밀히 취함으로써, 데이터 송신의 확실성 높임
  * 수신측은 전해받은 데이터를 원래 형태로 맞추어 에플리케이션 계층에 전달.
    1. TCP헤더의 정보에 따라 순서대로 맞추기.
       * 포트번호, 데이터 무사한지 확인하는 값등이 적혀있음
    2. 어플리케이션 계층의 프로토콜에 전달.\(포트번호 보고 판단\)
* 확실히 전달하기 위해
  * 연락방법
    * 통신상대에게 통신상태를 전하는 수단으로 TCP 헤더에 있는 6bit 컨트롤 플래그를 사용한다. 상대에게 전하고 싶은 항목을 '1'로 만들고 나머지는 '0'으로 둔다.
      * 컨트롤플래그\(각 비트별 의미\)
        * URG\(Urgent\)
        * ACK\(Acknowledgement\)
        * PSH\(PUSH\)
        * RST\(Reset\)
        * SYN\(Synchronize\)
        * FIN\(Fin\)
      * 상대와 서로 확인해가면서 주고받는것을 '핸드셰이크'라고 함.
      * TCP에서 통신 개시할 때, 3-way 핸드셰이크라고함.
    * 통신 시작전에 양쪽 모두 다룰 수 있는 데이터 양을 먼저 확인함.
      * 세그먼트사이즈: TCP 헤더를 붙인 패킷사이즈
      * 윈도우 사이즈 : 한번에 받을 수 있는 양
      * 두 수치가 작은쪽으로 맞춘다.
    * 통신 해제할 때, TCP 헤더의 컨트롤 플래그를 사용해 연락을 취한다.
  * 주고받기 흐름
    * TCP헤더에는 데이터 순서를 나타내는 번호\(시퀀스 번호\) 가 적혀있음.
    * 헤더를 확실히 받기 위해 이 번호를 사용하여 주고받기 수행.
      * 송신측: TCP헤더에 시퀀스 번호쓰고, 세그먼트 보냄
      * 수신측: 시퀀스 번호를 보고 순서대로 전달되었는지 확인후, 전달받은 세그먼트의 다음 번호를 송신측에 알려줌.
      * 송신측: 무사히 전달되었다는 걸 확인후, 다음 세그먼트 보냄
      * 수신측: 다음 세그만트 받고, 시퀀스 번호보고 순서대로 나열.
      * 세그먼트가 없어질때까지 반복
    * 모아서 보내기
      * 세그먼트를 하나씩 보내는것보다 여러개 보는게 효율적임
      * 통신 시작시, 윈도우 사이즈만큼씩 확인응답을 기다리지 않고, 모아 보낼 수 있음
      * 윈도우 사이즈는 통신 도중에 변경될 수 있다. 따라서, 상황에 맞게 사이즈 조절하여 통신 가능.
* 문제 발생 시 처리
  * TCP에는 '송수신 중 문제 발생시 세그먼트 재전송한다' 라는 약속이 있음
  * 딜정 시간이 기다려도 확인 응답이 없을 경우 이유 불문하고, 송신측은 세그먼트를 재전송한다.
    * 세그먼트의 지연 및 분실
    * 확인 응답의 지연 및 분실\(세그먼트가 중복되면 하나를 남기고 파기\)
    * 데이터의 파손\(송신 도중 데이터 깨져있으면 수신측에서는 해당 데이터를 파기하고, 확인응답을 보내지 않음. 깨진것 유무는 checksum 값을 통해 판단\)
  * 일정 횟수 이상 재전송 해도 확인응답이 없을경우, 송신측이 강제로 통신을 해제함. RST플래그를 1로 만들어서 종료.
* 수신측 처리
  * TCP 헤더에 적힌 포트번호를 보고 지정된 어플리케이션 프로토콜에 데이터 전달.
  * 데이터가 하나의 세그먼트로 묶여있으면 헤더를 제거하고 전달
  * 두개 이상 분할되어있으면 시퀀스 번호를 보고 세그먼트를 조립한 후 전달.
  * 조립한 데이터를 지정된 에플리케이션 프로토콜에 전달하면 TCP의 일은 끝
* UDP프로토콜
  * 통신 속도를 중시한 프로토콜
    * UDP에서는 사전 의논을 하지 않고 일방적으로 데이터를 보냄\(비커넥션형 통신\)
    * 수신측이 받을 수 있는 상태를 조사하지 않고 보냄, 무슨일이 생기더라도 재전송 하지 않음.
    * 수신측은 받아도 확인 응답을 보내지 않음. 데이터 깨져있으면 파기
  * 동시에 데이터 보낼 수 있음.
    * 멀티캐스트: 복수의 특정인에게 보냄
    * 브로드 캐스트: 불특정 다수에게 보냄
  * UDP가 하는일
    * 데이터가 깨졌는지 확인하고, 깨졌다면 파기
    * UDP헤더를 제거하고 지정된 애플리케이션 프로토콜에게 전달.
  * 확실성보다 실시간성이 중요시되는 통신이나, 데이터가 작은 네트워크 관리 통신, 스트리밍등에 사용됨.
* netstat명령\(cmd에서 실습\)
  * netstat만 쓰면 UDP는 보이지 않음 옵션으로 -a를 사용하면 보임
  * netstat

