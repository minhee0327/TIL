# 11. 가상메모리 \(Virtual Memory System\)

1. 개요

   > 실제 각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기가 한계가 있음
   >
   > * 예: 리눅스는 하나의 프로세스가 4GB임
   > * 통상메모리는 8GB, 16GB
   >
   >   폰노이만 구조 기반이므로 코드는 메모리에 반드시 있어야함.  
   >
   >   메모리와 process간의 dependency가 큰편
   >
   > * RAM을 관리하는 방법의 하나로 실제 메모리주소가 아닌 가상 메모리 주소를 주는방식
   > * 가상메모리가 필요한 이유
   >   * 여러 프로세스 동시 실행 시스템
   >     1. 메모리 용량 부족이슈
   >     2. 프로세스 메모리 영역간에 침범이슈
   > * 가상메모리: 메모리가 실제 메모리보다 많아보이게 하는 기술
   >   * 실제 사용하는 메모리는 작다는 점에 착안하여 고안된 기술
   >   * 프로세스간 공간 분리로, 프로세스 이슈가 전체 시스템에 영향을 주지 않음
   > * 기본아이디어
   >   * 프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고/쓸때만 물리주소로 바꿔주면 됨.
   >     * virtual address\(가상주소\): 프로세스가 참조하는주소 
   >       * \[0~4GB\]
   >       * 이 중에 **일부만 물리주소에 올라간다.**
   >     * physical address\(물리주소\): 실제 메모리 주소
   >   * MMU\(Memory Management Unit\)
   >     * CPU에 코드 실행시 가상 주소 메모리 접근이 필요할때 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치.
   >     * \(CPU에서 코드 실행시 가상주소 먼저 접근\)
   >   * 가상메모리\(Virtual Memory\)와 MMU
   >     * CPU는 가상메모리를 다루고, 실제 해당주소 접근시 MMU하드웨어 장치를 통해서 물리메모리에 접근한다.
   >       * **하드웨어 장치를 이용해야 주소변환이 빠르게 때문에 별도장치\(MMU\)를 둠.**
   >       * \[CPU\]=&gt; virtual address =&gt; \[MMU\] =&gt; physical address =&gt; \[Memory\] 
   >     * 프로세스 생성시, 페이지 테이블 정보 생성
   >       * PCB등에서 해당 페이지 테이블 접근 가능하고, 관련정보는 물리메모리에 적재
   >       * 프로세스 구동시, 해당 페이지 테이블 base주소가 별도 레지스터에 저장\(CR3\)
   >       * CPU가 가상 주소 접근시, MMU가 페이지 테이블 base주소를 접근해서, 물리 주소를 가져옴.

2. 가상메모리 메커니즘
   * **페이징시스템**
     * 페이징\(paging\)개념
       * 크기가 동일한 페이지로 가상주소공간과 이에 매칭하는 물리주소공간 관리
       * 하드웨어 지원이 필요
         * Intel X 86 시스템\(32bit\)에서는 4KB, 2MB, 1GB 지원
       * 리눅스에서는 4KB로 paging
       * 페이지 번호를 기반으로 \[가상주소:물리주소\] 매핑정보를 기록하고 사용함.
     * 예
       * 프로세스\(4GB\)의 PCB에 Page Table 구조체를 가리키는 주소가 들어있음
       * Page Table에는 가상주소와 물리주소간 매핑정보가 있음.
     * 페이징 시스템 구조
       * page 또는 page frame: 고정된 크기의 block\(4KB\)
       * paging system
         * 가상주소 v = \(p,d\)
           * p: 가상메모리 페이지
           * d: p안에서 참조하는 위치\(변위, offset\)
       * 페이지크기가 4KB인 예
         * 가상주소의 0bit~ 11bit가 변위\(d\)를 나타내고
         * 12bit이상이 페이지 번호가 될수있음.

           > 참고: 프로세스가 4GB를 사용하는 이유: 32bit 시스템에서 2³²가 4GB
     * page table\(페이지테이블\)
       * 물리주소에 있는 페이지 번호와 해당 페이지의 첫 물리주소 정보를 매핑한 표.
       * physical address에 들어가져있는지 여부를 확인하는 정보도 가지고있음.
     * paging system 동작
       * 해당 프로세스에서 특정 가상 주소에 엑세스를 하려면
         * 해당 프로세스의 page table에 해당 가상주소가 포함된 page번호가 있는지 확인
         * page 번호가 있으면 이 page가 매핑된 첫 물리주소를 알아내고\(p'\)
         * p'+d가 실제 물리주소가 됨. 
     * 다중단계 페이징 시스템
       * 32bit 시스템에서 4KB 페이지를 위한 페이징시스템은
         * 하위 12bit 는 offset
         * 상위 20bit 가 페이징 번호, 즉 2의 20승개의 페이지 정보필요
       * 페이징 정보를 단계를 나누어 생성
         * 필요없는 페이지는 생성하지 않으면 공간절약가능
         * 필요한 페이지만 페이지 테이블 생성하여 사용
     * MMU와 TLB\(컴퓨터 구조\)
       * MMU가 물리주소를 확인하기 위해 메모리를 갔다와야함.
       * 시간이 오래걸림
       * TLB\(Translation Lookaside Buffer\): 페이지 정보 캐쉬를 두고 caching
     * 페이징 시스템과 공유메모리
       * 프로세스간 동일한 물리주소를 가리킬수있음\(공간절약, 메모리시간할당시간절약\)
   * **세그멘테이션**
   * 가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트\(Segment\)로 분할
   * 페이징 기법에서는 가상 메모리를 같은 크기의 블록으로 분할
     * 예: X86 리얼모드
       * CS\(code Segment\), DS\(Data Segment\), SS\(Stack Segment\), ES\(Extra Segment\)로 세그먼트를 나누어 메모리 접근
       * 기존 80286 =&gt;\[보호모드 &lt;= protection ring \(user/kernel\)\] &lt;-&gt; 8086/80186CPU 소프트웨어
       * 부팅시 모드가 리얼모드 =&gt; 보호모드로 
   * 세그먼트 가상주소
     * v = \(s,d\)
       * s: 세그먼트 번호
       * d: 블록 내 세그먼트 변위\(offset\)
   * 세그멘테이션 기법
     * 세그멘테이션은 크기가 다른 세그먼트 단위로 물리 메로리에 로딩
3. 참고
   * 내부단편화\(페이지기법\)
     * 페이지 블록만큼 데이터가 딱 맞게 채워져 있지 않을 때, 공간낭비
   * 외부단편화\(세그멘테이션 기법\)
     * 물리메모리가 원하는 연속된 크기의 메모리를 제공해주지 못하는 경우
   * 세그멘테이션/ 페이징 모두 하드웨어 지원필요
     * 다양한 컴퓨터 시스템에 이식성을 중요시하는 리눅스는 페이징 기법을 기반으로 구현.

* 페이지 폴트, 세그멘테이션은 image가 많아서, evernote에 정리.

