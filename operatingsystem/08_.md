# 08 프로세스와 컨텍스트 스위칭

* 프로세스 구조\(영역\)
  * STACK
    * 함수
      * 함수를 위해 동적으로 계속 처리해야하는 공간이 필요함.
      * return address\(주소\)값을 스택에 저장해둠
      * 인자, 지역변수들을 차례로 넣고, return address로 함수 결과값을 반환함
  * HEAP
    * 대표적인 예\(C 에서 malloc\(\)\)
    * 코드 내에서, 동적으로 사용할 데이터들 저장
    * 동적으로 메모리를 생성함
    * malloc 함수 내부에 메모리 크기 지정, \(통상적으로 32bit 할당\)
    * \(사용후 free로 할당 해지해야함\)
  * DATA
    * 변수
      * 메모리의 특정 공간을 만들어서 DATA를 넣고 뺌
    * 영역\(2가지\)
      * BSS
        * 초기화되지 않은 전역변수
      * DATA
        * 초기값이 있는 전역변수
  * CODE
    * 컴파일된 소스코드 저장
    * code가 컴파일 된다는 것은 0과1로 이루어진 기계어로 변환된다는 뜻\(=바이너리\)
    * 읽기 전용
* 프로세스 구조와 컴퓨터 구조
  * 주요 레지스터중 PC\(Program Counter\) + SP\(Stack Pointer\)
    * PC: 다음 명령어의 위치를 가리키는 포인터\[명령어는 순차처리 되므로, 한 명령어가 처리되면 자동으로 값이 증가됨\]
    * SP: LIFO, 현재 스택의 위치 정보를 지니는 포인터\(이 값을 저장하는 레지스터를 SP레지스터\)
    * EBP: 함수가 호출된 최상단 스택포인터를 가지고 있음.\(G함수 호출에 문제가 생겼을 때, 이 위치를 찾아\(트래킹\) 감.\)
    * EAX: 함수 내부 동작이 끝나서 반환한 값이 저장되는 레지스터
    * FP: 함수 호출 종료시 스택프레임의 반환을 위해 이전 스택 포인터의 정보를 지니는 포인터
* 프로세스와 컨텍스트 스위칭
  * context switching\(문맥교환\)
    * CPU에 실행할 프로세스를 교체하는 기술
      * 실행 중지할 프로세스 정보\(PC, SP등\) 를 해당 프로세스의 PCB에 업데이트해서 메인메모리에 저장.\(프로세스 상태는 ready혹은 block상태로\)
      * 다음 실행할 프로세스 정보를 메인메모리에 있는 해당 PCB\(PC, SP등\)를 CPU에 넣고 실행\(running 상태, 해당 PC의 위치부터 실행\)

        > dispatch: ready =&gt; running상태로
    * 실제로는 굉장히 짧은 시간\(ms\)단위로 컨텍스트 스위칭이 빈번하게 일어남
    * C언어가 아니라 어셈블리어로 작성되어있다.

      > 참고: 컴파일을 하는 시간을 줄이기 위해, 어셈블리어 작성.  
      > 어셈블리어는 이식성은 떨어지지만, 속도측면에서는 빠르기 때문에 사용  
      > 이식성: CPU아키텍쳐에 따라 기존 코드 재작성하는 것
  * PCB: \(Process Control Block, Process Context Block\)
    * Process ID
    * Register 값\(PC, SP\)
    * Scheduling Info\(Process State\)
    * Memory Info \(메모리사이즈 limit\)
    * 등등 \(프로세스의 상태를 저장\)

      > 프로세스가 실행중인 상태를 캡쳐/구조화 해서 저장

